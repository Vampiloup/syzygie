
function init(self)
	
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "use_camera_projection")
	msg.post("#camera", "acquire_camera_focus")

	-- Put camera at the center of the map
	local pos_X = map_X/2
	local pos_Y = map_Y/2
	local pos = vmath.vector3(pos_X, pos_Y, 10)
	print ("set position center")
	go.set_position(pos)

	msg.post("/curseur", "debut_camera", {position = pos})

	-- Allow the wheel function to accept inputs.
	self.wheel = 0

	-- If "wheelclick" pressed (1) or not/released (0)
	self.wheelclick = false
	self.wheelclick_pos = pos
	self.wheelclick_camera_pos = go.get_position()
	self.pressed_time = socket.gettime()

	
end

function final(self)
	msg.post("camera", "release_camera_focus")
	msg.post(".", "release_input_focus")
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed	
end



function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)

	-- Received signal that zoom change are finished at curseur.script. Allow the wheel function to receive inputs.
	if message_id == hash("wheel_retour") and message["wheel_retour"] == 0 then
		self.wheel = 0
	end
		
end

function on_input(self, action_id, action)

	-- get camera position
	local position = go.get_position()
	local zoom = go.get("#camera","orthographic_zoom")

	if action.pressed  and (action_id == hash("wheelclick")) then
		self.wheelclick = true
		self.wheelclick_pos = vmath.vector3(action.x, action.y, 10)
		self.wheelclick_camera_pos = go.get_position()
	elseif action.released then
		self.wheelclick = false
	end

	-- Double click 
	if action.pressed  and (action_id == hash("touch")) and not node_entered and not node_enabled then

		if socket.gettime() < self.pressed_time + dbl_click_delay then
			a,b = screen_to_world(action.x, action.y, 10)
			go.set_position(vmath.vector3(a,b, 10))
		end
		self.pressed_time = socket.gettime()
	end

	
	if self.wheelclick == true then

		-- moving camera with the mouse
		local position = self.wheelclick_camera_pos + (self.wheelclick_pos - vmath.vector3(action.x, action.y, 0)) / zoom
		if position.x < 1 then
			position.x = 1
		end
		if position.y < 1 then
			position.y = 0
		end
		if position.x > map_X then
			position.x = map_X
		end
		if position.y > map_Y then
			position.y = map_Y
		end
		go.set_position(position)			
	elseif action_id == hash("right") and (position.x < map_X) then
	-- moving camera with the keyboard
		position.x = position.x + (5 / zoom)
		go.set_position(position)
	elseif action_id == hash("left") and (position.x > 0) then
		position.x = position.x - (5 / zoom)
		go.set_position(position)
	elseif action_id == hash("up") and (position.y < map_Y) then
		position.y = position.y + (5 / zoom)
		go.set_position(position)
	elseif action_id == hash("down") and (position.y > 0) then
		position.y = position.y - (5 / zoom)
		go.set_position(position)
	elseif action_id == hash("wheelup") and self.wheel < 1 then
	-- zooming
		self.wheel = 1
		msg.post("/curseur#curseur", "wheel", {wheel = 1})
		zoom_state = zoom_state + 1
		if zoom_state > zoom_max then
			zoom_state = zoom_max
		end
		go.set("#camera", "orthographic_zoom", 1*(math.pow(zoom_gap, zoom_state)))
	elseif action_id == hash("wheeldown") and self.wheel < 1  then
		self.wheel = 1
		msg.post("/curseur#curseur", "wheel", {wheel = 2})
		zoom_state = zoom_state - 1
		if zoom_state < zoom_min then
			zoom_state = zoom_min
		end
		go.set("#camera", "orthographic_zoom", 1*(math.pow(zoom_gap, zoom_state)))
	end
	
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
